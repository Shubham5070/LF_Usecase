"""Unit test: forecasting_agent should use saved predictions when present and need_model_run=True

This test inserts a small synthetic prediction row into
`t_predicted_demand_chatbot` and verifies that
`forecasting_agent` fetches it instead of attempting to run the model.

The test is lightweight and does NOT invoke the ML model.
"""
from datetime import datetime
from db_factory import DatabaseFactory
from agents import forecasting_agent
from state import GraphState

TEST_DATE = "2026-01-15"


def ensure_table_and_insert_sample(conn):
    cur = conn.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS t_predicted_demand_chatbot (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        model_id INTEGER,
        prediction_date TEXT,
        generated_at TEXT,
        datetime TEXT,
        block INTEGER,
        predicted_demand REAL,
        horizon_type TEXT,
        version TEXT
    )
    """)
    conn.commit()

    # Clean any previous test rows for deterministic behaviour
    cur.execute(
        "DELETE FROM t_predicted_demand_chatbot WHERE prediction_date = ?",
        (TEST_DATE,)
    )
    conn.commit()

    # Insert 2 sample rows (minimal)
    rows = [
        (999, TEST_DATE, datetime.utcnow().isoformat(), f"{TEST_DATE} 00:00:00", 1, 123.4, 'day_ahead', 'test-model'),
        (999, TEST_DATE, datetime.utcnow().isoformat(), f"{TEST_DATE} 00:15:00", 2, 125.6, 'day_ahead', 'test-model'),
    ]

    cur.executemany(
        "INSERT INTO t_predicted_demand_chatbot (model_id, prediction_date, generated_at, datetime, block, predicted_demand, horizon_type, version) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
        rows,
    )
    conn.commit()


def test_forecasting_agent_forces_model_run_and_uses_postrun_rows(monkeypatch):
    """When planner requests a model run we must always run the model (ignore pre-existing rows)
    and return only the rows generated by the run. The test monkeypatches the model tool so
    it inserts deterministically short sample output and returns quickly.
    """
    conn = DatabaseFactory.get_connection()
    try:
        # Insert pre-existing rows that should be IGNORED by the forced run
        ensure_table_and_insert_sample(conn)

        # Prepare a small set of "new" rows that the mocked model-run will insert
        NEW_MODEL_ID = 555
        def fake_model_run_invoke(run_date_str):
            cur = conn.cursor()
            # remove any existing rows for determinism (simulating run_and_store_forecast behavior)
            cur.execute("DELETE FROM t_predicted_demand_chatbot WHERE prediction_date = ?", (run_date_str,))
            conn.commit()

            rows = [
                (NEW_MODEL_ID, run_date_str, datetime.utcnow().isoformat(), f"{run_date_str} 00:00:00", 1, 200.1, 'day_ahead', 'fake-model'),
                (NEW_MODEL_ID, run_date_str, datetime.utcnow().isoformat(), f"{run_date_str} 00:15:00", 2, 201.2, 'day_ahead', 'fake-model'),
            ]
            cur.executemany(
                "INSERT INTO t_predicted_demand_chatbot (model_id, prediction_date, generated_at, datetime, block, predicted_demand, horizon_type, version) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                rows,
            )
            conn.commit()
            return {"ok": True, "rows_written": len(rows), "model_id": NEW_MODEL_ID}

        # Monkeypatch the tool so the agent uses our deterministic fake run
        import types, tools as _tools
        monkeypatch.setattr(_tools, 'model_run_tool', types.SimpleNamespace(invoke=lambda date: fake_model_run_invoke(date)))

        state = GraphState(user_query=f"Give forecast for {TEST_DATE}")
        state.need_model_run = True

        result_state = forecasting_agent(state)

        assert result_state.data_ref is not None
        assert result_state.data_ref.get("ok") is True
        assert result_state.data_ref.get("row_count", 0) >= 2
        assert result_state.data_ref.get("generated_by_run") is True

        # Ensure returned rows are the ones created by the fake run (model_id matches)
        returned_model_ids = {r.get('model_id') for r in result_state.data_ref.get('rows', [])}
        assert returned_model_ids == {NEW_MODEL_ID}

    finally:
        # cleanup
        cur = conn.cursor()
        cur.execute("DELETE FROM t_predicted_demand_chatbot WHERE prediction_date = ?", (TEST_DATE,))
        conn.commit()
        conn.close()